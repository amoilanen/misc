 use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs; // For file writing
use std::io::{self, Write};
use std::process::{Command, Stdio}; // For running commands

// Represents a single step in the execution plan.
// We'll need to refine this based on how the LLM structures its plan output.
// Using serde helps if the LLM can output structured data (like JSON).
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "action", rename_all = "snake_case")] // Helps with parsing LLM output if JSON
pub enum Action {
    /// Create a file with the specified content.
    CreateFile { path: String, content: String },
    /// Execute a shell command.
    RunCommand { command: String },
    /// Search the web for information (details TBD).
    SearchWeb { query: String },
    /// Ask the user a question (e.g., for clarification).
    AskUser { question: String },
    /// Delete a file.
    DeleteFile { path: String },
    /// Edit/Overwrite a file with new content.
    EditFile { path: String, content: String },
    /// Final response or summary action.
    Respond { message: String },
}

// Represents the overall plan generated by the LLM.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Plan {
    pub thought: Option<String>, // LLM's reasoning for the plan
    pub steps: Vec<Action>,
}

impl Plan {
    /// Displays the plan to the user in a readable format.
    pub fn display(&self) {
        println!("\n--- Proposed Plan ---");
        if let Some(thought) = &self.thought {
            println!("Thought: {}", thought);
        }
        if self.steps.is_empty() {
            println!("No actions planned.");
            return;
        }
        for (i, action) in self.steps.iter().enumerate() {
            match action {
                Action::CreateFile { path, content } => println!("{}. Create file '{}' with content:\n{}", i + 1, path, content),
                Action::RunCommand { command } => println!("{}. Run command: `{}`", i + 1, command),
                Action::SearchWeb { query } => println!("{}. Search web for: '{}'", i + 1, query),
                Action::AskUser { question } => println!("{}. Ask user: '{}'", i + 1, question),
                Action::DeleteFile { path } => println!("{}. Delete file: '{}'", i + 1, path),
                Action::EditFile { path, content } => println!("{}. Edit file '{}' with content:\n{}", i + 1, path, content),
                Action::Respond { message } => println!("{}. Respond: '{}'", i + 1, message),
            }
        }
        println!("--------------------");
    }
}

/// Executes the plan step by step, asking for confirmation unless auto_confirm is true.
pub async fn execute_plan(plan: &Plan, auto_confirm: bool) -> Result<()> {
    println!("\n--- Executing Plan ---");
    if plan.steps.is_empty() {
        println!("No actions to execute.");
        return Ok(());
    }

    let mut current_auto_confirm = auto_confirm;

    for (i, action) in plan.steps.iter().enumerate() {
        println!("\n--- Step {}/{}: {:?} ---", i + 1, plan.steps.len(), action);

        let mut confirmed = current_auto_confirm;
        if !current_auto_confirm {
            print!("Execute this step? (y/N/all): ");
            io::stdout().flush()?;
            let mut input = String::new();
            io::stdin().read_line(&mut input)?;
            let choice = input.trim().to_lowercase();
            if choice == "y" || choice == "yes" {
                confirmed = true;
            } else if choice == "a" || choice == "all" {
                confirmed = true;
                current_auto_confirm = true;
            } else {
                println!("Skipping step {}.", i + 1);
                continue;
            }
        }

        if confirmed {
            match action {
                Action::CreateFile { path, content } => {
                    println!("  Action: Create file '{}'", path);
                    // Ensure parent directory exists
                    if let Some(parent_dir) = std::path::Path::new(path).parent() {
                        fs::create_dir_all(parent_dir)
                            .with_context(|| format!("Failed to create parent directories for '{}'", path))?;
                    }
                    fs::write(path, content)
                        .with_context(|| format!("Failed to write file: {}", path))?;
                    println!("  Success: File '{}' created.", path);
                }
                Action::EditFile { path, content } => {
                    println!("  Action: Edit/Overwrite file '{}'", path);
                    // Check if file exists before overwriting (optional, but good practice)
                    if !std::path::Path::new(path).exists() {
                        println!("  Warning: File '{}' does not exist, creating it.", path);
                        // Ensure parent directory exists if creating anew
                        if let Some(parent_dir) = std::path::Path::new(path).parent() {
                            fs::create_dir_all(parent_dir)
                                .with_context(|| format!("Failed to create parent directories for '{}'", path))?;
                        }
                    }
                    fs::write(path, content)
                        .with_context(|| format!("Failed to write file: {}", path))?;
                    println!("  Success: File '{}' updated.", path);
                }
                Action::DeleteFile { path } => {
                    println!("  Action: Delete file '{}'", path);
                    if std::path::Path::new(path).exists() {
                        fs::remove_file(path)
                            .with_context(|| format!("Failed to delete file: {}", path))?;
                        println!("  Success: File '{}' deleted.", path);
                    } else {
                        println!("  Warning: File '{}' does not exist, skipping deletion.", path);
                    }
                }
                Action::RunCommand { command } => {
                    println!("  Action: Run command `{}`", command);
                    // Execute the command using the default shell
                    // Note: This is basic execution. Error handling and output capturing can be improved.
                    // Security Note: Running arbitrary commands from an LLM is risky!
                    // Consider sandboxing or more specific actions if needed.
                    let shell = std::env::var("SHELL").unwrap_or_else(|_| "/bin/sh".to_string());
                    let mut cmd = Command::new(shell);
                    cmd.arg("-c"); // Tell the shell to execute the following string
                    cmd.arg(command);

                    // Redirect stdio to inherit from the parent process so output appears in the terminal
                    cmd.stdin(Stdio::inherit());
                    cmd.stdout(Stdio::inherit());
                    cmd.stderr(Stdio::inherit());

                    let status = cmd.status()
                        .with_context(|| format!("Failed to execute command: {}", command))?;

                    if status.success() {
                        println!("  Success: Command executed successfully.");
                    } else {
                        // Error is already printed to stderr due to Stdio::inherit
                        anyhow::bail!("Command failed with status: {}", status);
                    }
                }
                Action::SearchWeb { query } => {
                    println!("  Action: Search web for '{}'", query);
                    println!("  (Web search not yet implemented)");
                    // For now, treat as non-fatal, maybe just log it
                    // Err(anyhow::anyhow!("Web search not implemented"))?
                    println!("  Skipping: Web search functionality is not available.");
                }
                Action::AskUser { question } => {
                    println!("  Action: Ask user '{}'", question);
                    println!("  (Asking user not yet implemented)");
                    // Err(anyhow::anyhow!("Asking user not implemented"))?
                    println!("  Skipping: Asking user functionality is not available.");
                }
                Action::Respond { message } => {
                    println!("--- Final Response ---");
                    println!("{}", message);
                    println!("----------------------");
                }
            }
        } else {
            // Already printed "Skipping step..."
        }
        // Optional: Add a small delay between steps
        // tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    }
    println!("\n--- Plan Execution Finished ---");
    Ok(())
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plan_serialization() {
        let plan = Plan {
            thought: Some("Create a hello world script and run it".to_string()),
            steps: vec![
                Action::CreateFile {
                    path: "hello.sh".to_string(),
                    content: "#!/bin/bash\necho 'Hello World!'".to_string(),
                },
                Action::RunCommand {
                    command: "bash hello.sh".to_string(),
                },
                 Action::Respond { message: "Script executed.".to_string() },
            ],
        };

        // Example: Serialize to JSON (how an LLM might return it)
        let json = serde_json::to_string_pretty(&plan).unwrap();
        println!("Serialized Plan:\n{}", json);

        // Deserialize back
        let deserialized_plan: Plan = serde_json::from_str(&json).unwrap();

        assert_eq!(plan.steps.len(), deserialized_plan.steps.len());
        assert!(matches!(deserialized_plan.steps[0], Action::CreateFile { .. }));
        assert!(matches!(deserialized_plan.steps[1], Action::RunCommand { .. }));
        assert!(matches!(deserialized_plan.steps[2], Action::Respond { message: _ }));
    }

     // Note: Testing execute_plan requires mocking filesystem, commands etc.
     // This is more involved and can be added later.
}
