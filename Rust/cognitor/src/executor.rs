use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs; // For file writing
use std::io::{self, Write};
use std::process::{Command, Stdio}; // For running commands

// Represents a single step in the execution plan.
// We'll need to refine this based on how the LLM structures its plan output.
// Using serde helps if the LLM can output structured data (like JSON).
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "action", rename_all = "snake_case")] // Helps with parsing LLM output if JSON
pub enum Action {
    /// Create a file with the specified content.
    CreateFile { path: String, content: String },
    /// Execute a shell command.
    RunCommand { command: String },
    /// Search the web for information (details TBD).
    SearchWeb { query: String },
    /// Ask the user a question (e.g., for clarification).
    AskUser { question: String },
    /// Final response or summary action.
    Respond { message: String },
    // Add other actions as needed (e.g., ReadFile, EditFile)
}

// Represents the overall plan generated by the LLM.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Plan {
    pub thought: Option<String>, // LLM's reasoning for the plan
    pub steps: Vec<Action>,
}

impl Plan {
    /// Displays the plan to the user in a readable format.
    pub fn display(&self) {
        println!("\n--- Proposed Plan ---");
        if let Some(thought) = &self.thought {
            println!("Thought: {}", thought);
        }
        if self.steps.is_empty() {
            println!("No actions planned.");
            return;
        }
        for (i, action) in self.steps.iter().enumerate() {
            match action {
                Action::CreateFile { path, content } => println!("{}. Create file '{}' with content:\n{}", i + 1, path, content),
                Action::RunCommand { command } => println!("{}. Run command: `{}`", i + 1, command),
                Action::SearchWeb { query } => println!("{}. Search web for: '{}'", i + 1, query),
                Action::AskUser { question } => println!("{}. Ask user: '{}'", i + 1, question),
                Action::Respond { message } => println!("{}. Respond: '{}'", i + 1, message),
            }
        }
        println!("--------------------");
    }

    /// Asks the user for confirmation to execute the plan.
    pub fn confirm_execution(&self) -> Result<bool> {
        print!("Do you want to execute this plan? (y/N): ");
        io::stdout().flush()?; // Ensure the prompt is shown before reading input

        let mut input = String::new();
        io::stdin().read_line(&mut input)?;

        Ok(input.trim().eq_ignore_ascii_case("y"))
    }
}

/// Executes the plan step by step.
/// This requires integration with actual execution logic (filesystem, shell, web search).
pub async fn execute_plan(plan: &Plan) -> Result<()> {
    println!("\n--- Executing Plan ---");
    for (i, action) in plan.steps.iter().enumerate() {
        println!("\nExecuting step {}: {:?}", i + 1, action);
        match action {
            Action::CreateFile { path, content } => {
                println!("  Action: Create file '{}'", path);
                // Ensure parent directory exists
                if let Some(parent_dir) = std::path::Path::new(path).parent() {
                    fs::create_dir_all(parent_dir)
                        .with_context(|| format!("Failed to create parent directories for '{}'", path))?;
                }
                fs::write(path, content)
                    .with_context(|| format!("Failed to write file: {}", path))?;
                println!("  Success: File '{}' created.", path);
            }
            Action::RunCommand { command } => {
                println!("  Action: Run command `{}`", command);
                // Execute the command using the default shell
                // Note: This is basic execution. Error handling and output capturing can be improved.
                // Security Note: Running arbitrary commands from an LLM is risky!
                // Consider sandboxing or more specific actions if needed.
                let shell = std::env::var("SHELL").unwrap_or_else(|_| "/bin/sh".to_string());
                let mut cmd = Command::new(shell);
                cmd.arg("-c"); // Tell the shell to execute the following string
                cmd.arg(command);

                // Redirect stdio to inherit from the parent process so output appears in the terminal
                cmd.stdin(Stdio::inherit());
                cmd.stdout(Stdio::inherit());
                cmd.stderr(Stdio::inherit());

                let status = cmd.status()
                    .with_context(|| format!("Failed to execute command: {}", command))?;

                if status.success() {
                    println!("  Success: Command executed successfully.");
                } else {
                    // Error is already printed to stderr due to Stdio::inherit
                    anyhow::bail!("Command failed with status: {}", status);
                }
            }
            Action::SearchWeb { query } => {
                println!("  Action: Search web for '{}'", query);
                println!("  (Web search not yet implemented)");
                Err(anyhow::anyhow!("Web search not implemented"))?
            }
            Action::AskUser { question } => {
                println!("  Action: Ask user '{}'", question);
                println!("  (Asking user not yet implemented)");
                Err(anyhow::anyhow!("Asking user not implemented"))?
            }
            Action::Respond { message } => {
                println!("--- Final Response ---");
                println!("{}", message);
                println!("----------------------");
            }
        }
        // Add a small delay or confirmation step between actions if desired
        // tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    }
    println!("\n--- Plan Execution Finished ---");
    Ok(())
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plan_serialization() {
        let plan = Plan {
            thought: Some("Create a hello world script and run it".to_string()),
            steps: vec![
                Action::CreateFile {
                    path: "hello.sh".to_string(),
                    content: "#!/bin/bash\necho 'Hello World!'".to_string(),
                },
                Action::RunCommand {
                    command: "bash hello.sh".to_string(),
                },
                 Action::Respond { message: "Script executed.".to_string() },
            ],
        };

        // Example: Serialize to JSON (how an LLM might return it)
        let json = serde_json::to_string_pretty(&plan).unwrap();
        println!("Serialized Plan:\n{}", json);

        // Deserialize back
        let deserialized_plan: Plan = serde_json::from_str(&json).unwrap();

        assert_eq!(plan.steps.len(), deserialized_plan.steps.len());
        assert!(matches!(deserialized_plan.steps[0], Action::CreateFile { .. }));
        assert!(matches!(deserialized_plan.steps[1], Action::RunCommand { .. }));
        assert!(matches!(deserialized_plan.steps[2], Action::Respond { .. }));
    }

     // Note: Testing execute_plan requires mocking filesystem, commands etc.
     // This is more involved and can be added later.
}
